using System;
using System.Threading;
using System.Threading.Tasks;

namespace Telemetry
{
    /// <summary>
    /// Analog Inputs/Outputs:
    /// 
    /// The Umbilical Interface Assembly(UIA) is located in the airlock and provides controls
    /// which the astronaut uses to prepare the suit for EVA.The telemetry stream provides
    /// both input and output on the UIA.The values generated by the telemetry stream should
    /// reflect the inputs in the UIA control section.
    /// The Display and Control Unit (DCU) is a wearable device that controls the suit during
    /// the EVA. Use these inputs to respond to suit anomalies.
    /// </summary>
    public class UIAData
    {
    //    public readonly string Id;
    //    public readonly DateTime StartedAt;
    //    public readonly OnOff EMU1;
    //    public readonly OnOff EMU2;
    //    public readonly int O2SupplyPressure1;
    //    public readonly int O2SupplyPressure2;
    //    public readonly OpenClose EV1Supply;
    //    public readonly OpenClose EV2Supply;
    //    public readonly OpenClose EV1Waste;
    //    public readonly OpenClose EV2Waste;
    //    public readonly OpenClose EMU1_O2;
    //    public readonly OpenClose EMU2_O2;
    //    public readonly int OxygenSupplyOut1;
    //    public readonly int OxygenSupplyOut2;
    //    public readonly OpenClose O2Vent;
    //    public readonly Fault DepressPump;
    //    public readonly int _V;

    //    public UIAData(TelemetryAPI.UIADataRaw d)
    //    {
    //        Id = d._id;
    //        StartedAt = DateTime.Parse(d.started_at);
    //        EMU1 = d.emu1 == "ON" ? OnOff.ON : OnOff.OFF;
    //        EMU2 = d.emu2 == "ON" ? OnOff.ON : OnOff.OFF;
    //        O2SupplyPressure1 = d.o2_supply_pressure1;
    //        O2SupplyPressure2 = d.o2_supply_pressure2;
    //        EV1Supply = d.ev1_supply == "OPEN" ? OpenClose.OPEN : OpenClose.CLOSE;
    //        EV2Supply = d.ev2_supply == "OPEN" ? OpenClose.OPEN : OpenClose.CLOSE;
    //        EV1Waste = d.ev1_waste == "OPEN" ? OpenClose.OPEN : OpenClose.CLOSE;
    //        EV2Waste = d.ev2_waste == "OPEN" ? OpenClose.OPEN : OpenClose.CLOSE;
    //        EMU1_O2 = d.emu1_O2 == "OPEN" ? OpenClose.OPEN : OpenClose.CLOSE;
    //        EMU2_O2 = d.emu2_O2 == "OPEN" ? OpenClose.OPEN : OpenClose.CLOSE;
    //        OxygenSupplyOut1 = d.oxygen_supp_out1;
    //        OxygenSupplyOut2 = d.oxygen_supp_out2;
    //        O2Vent = d.O2_vent == "OPEN" ? OpenClose.OPEN : OpenClose.CLOSE;
    //        DepressPump = d.depress_pump == "FAULT" ? Fault.FAULT : Fault.NOFAULT;
    //        _V = d.__v;
    //    }
    //}

    //public enum OnOff { OFF = 0, ON = 1 }
    //public enum OpenClose { CLOSE = 0, OPEN = 1 }
    //public enum Fault { FAULT = 0, NOFAULT = 1 }

    ///// <summary>
    ///// Class used to manage UIA. These values can be modified by changing settings on the physical DCU device
    ///// </summary>
    //class UIAStream
    //{
    //    /// <summary>
    //    /// singleton instance
    //    /// </summary>
    //    private static readonly Lazy<UIAStream> lazyStream = new Lazy<UIAStream>(() => new UIAStream());

    //    /// <summary>
    //    /// Stream used to access UIA data
    //    /// </summary>
    //    public static UIAStream stream { get { return lazyStream.Value; } }

    //    //
    //    // implementation of class
    //    //

    //    /// <summary>
    //    /// token used to cancel polling loop
    //    /// </summary>
    //    private CancellationTokenSource cancellationToken;

    //    /// <summary>
    //    /// Data structure storing current UIA state. Updated every second.
    //    /// This structure can be null when not initialized or when request results in error.
    //    /// </summary>
    //    public UIAData Data { get; private set; }

    //    /// <summary>
    //    /// Default constructor. Starts polling server every second for updates to data.
    //    /// </summary>
    //    private UIAStream()
    //    {
    //        cancellationToken = new CancellationTokenSource();
    //        var token = cancellationToken.Token;
    //        Data = null;
    //        Task.Run(async () =>
    //        {
    //            // run infite loop polling server every second
    //            while (true)
    //            {
    //                try
    //                {
    //                    var api = new TelemetryAPI("http://localhost:3000"); //TODO: use configuration variable

    //                    var rawData = await api.GetUIAData();

    //                    // convert to custom object type
    //                    var newData = new UIAData(rawData);
    //                    Data = newData;

    //                    // notify subscribers

    //                    await Task.Delay(1000); // delay 1 second between requests
    //                }
    //                catch (Exception e)
    //                {
    //                    Console.Error.WriteLine(e.Message);
    //                    Console.Error.WriteLine(e.StackTrace);
    //                    Console.Error.WriteLine(e.Source);
    //                    Data = null;
    //                    await Task.Delay(1000);
    //                    continue;
    //                }
    //            }
    //        }, token);
    //    }


    //    public void Subscribe<T>(Func<UIAData, T> accessor, Func<T, bool> doNotify)
    //    {

    //    }

    //    public void Subscribe<T>(Func<UIAData, T> accessor)
    //    {

    //    }

    //    public void Subscribe(Action<UIAData> data)
    //    {

    //    }
    }
}